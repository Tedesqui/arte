<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>AR Graffiti — Protótipo Corrigido</title>
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family:system-ui, Arial; }
    #ui { position:fixed; left:10px; top:10px; z-index:9999; background:rgba(0,0,0,0.45); padding:10px; border-radius:8px; }
    #canvas2d { position:fixed; left:0; top:0; touch-action:none; z-index:2; display:none; /* Começa escondido */ }
    #btns { margin-top:8px; display:flex; gap:6px; }
    .hidden { display:none; }
    label{font-size:13px}
    input[type=color]{width:40px;height:28px;padding:0;border:0}
    input[type=range]{width:120px}
    #status{font-size:12px;margin-top:6px;color:#ddd}
    #loginBox{display:flex;flex-direction:column;gap:6px}
    #threeContainer{width:100%;height:100%;}
    /* Estilo para o botão de AR gerado pelo ARButton.js */
    #ARButton { bottom: 20px !important; top: unset !important; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="authUI">
      <div id="loginBox">
        <label>Login (email)</label>
        <input id="email" type="email" placeholder="seu@email.com" />
        <label>Senha</label>
        <input id="password" type="password" placeholder="senha" />
        <div id="btns">
          <button id="btnLogin">Entrar</button>
          <button id="btnRegister">Criar conta</button>
        </div>
      </div>
      <div id="userInfo" class="hidden">
        <div id="userEmail"></div>
        <button id="btnLogout">Sair</button>
      </div>
    </div>

    <hr />
    <div id="controls" class="hidden">
      <div>
        <label>Cor:</label>
        <input id="colorPicker" type="color" value="#ff0000" />
        <label style="margin-left:8px">Espessura:</label>
        <input id="thickness" type="range" min="1" max="60" value="6" />
      </div>
      <div style="margin-top:8px">
        <button id="btnClear">Limpar</button>
        <button id="btnSave">Salvar Arte</button>
      </div>
      <div id="status">Status: esperando iniciar</div>
    </div>
  </div>

  <canvas id="canvas2d"></canvas>
  <div id="threeContainer"></div>

  <script src="https://unpkg.com/three@0.156.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.156.0/examples/jsm/webxr/ARButton.js"></script>

  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-storage-compat.js"></script>

  <script>
  /******************************************************************
   * CONFIGURAÇÃO FIREBASE
   ******************************************************************/
  const firebaseConfig = {
    apiKey: "AIzaSyDayAFq_87J5G98mT2ASTwP2JAKRvkyE40",
    authDomain: "tomorrow-art-2694d.firebaseapp.com",
    projectId: "tomorrow-art-2694d",
    storageBucket: "tomorrow-art-2694d.appspot.com",
    messagingSenderId: "932174355356",
    appId: "1:932174355356:web:a4f30e7b3e15b5f1564659",
    measurementId: "G-DNJKP24S8K"
  };
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();
  const storage = firebase.storage();

  // Elementos da UI
  const ui = document.getElementById('ui');
  const loginBox = document.getElementById('loginBox');
  const userInfo = document.getElementById('userInfo');
  const userEmail = document.getElementById('userEmail');
  const controls = document.getElementById('controls');
  const statusEl = document.getElementById('status');

  /******************************************************************
   * AUTENTICAÇÃO
   ******************************************************************/
  document.getElementById('btnLogin').onclick = async ()=>{
    const email = document.getElementById('email').value; const pass = document.getElementById('password').value;
    try{ await auth.signInWithEmailAndPassword(email, pass); }catch(e){ alert('Erro login: '+e.message) }
  }
  document.getElementById('btnRegister').onclick = async ()=>{
    const email = document.getElementById('email').value; const pass = document.getElementById('password').value;
    try{ await auth.createUserWithEmailAndPassword(email, pass); alert('Conta criada, você está logado.'); }catch(e){ alert('Erro registrar: '+e.message) }
  }
  document.getElementById('btnLogout').onclick = ()=> auth.signOut();
  auth.onAuthStateChanged(user=>{
    if(user){
      loginBox.classList.add('hidden');
      userInfo.classList.remove('hidden');
      controls.classList.remove('hidden');
      userEmail.textContent = user.email;
      statusEl.textContent = 'Pronto para iniciar AR.';
    }else{
      loginBox.classList.remove('hidden');
      userInfo.classList.add('hidden');
      controls.classList.add('hidden');
    }
  });

  /******************************************************************
   * Canvas 2D (Desenho)
   ******************************************************************/
  const canvas2d = document.getElementById('canvas2d');
  const ctx = canvas2d.getContext('2d');
  function resizeCanvas(){ canvas2d.width = window.innerWidth; canvas2d.height = window.innerHeight; }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  let drawing = false; let last = null;
  const colorInput = document.getElementById('colorPicker');
  const thicknessInput = document.getElementById('thickness');

  function getPointer(e){
    if(e.touches) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }

  canvas2d.addEventListener('pointerdown', (e)=>{ drawing = true; last = getPointer(e); });
  canvas2d.addEventListener('pointermove', (e)=>{
    if(!drawing) return;
    const p = getPointer(e);
    ctx.strokeStyle = colorInput.value; ctx.lineWidth = thicknessInput.value; ctx.lineCap = 'round';
    ctx.beginPath(); ctx.moveTo(last.x, last.y); ctx.lineTo(p.x, p.y); ctx.stroke();
    last = p;
  });
  window.addEventListener('pointerup', ()=>{ drawing=false; last=null; });
  document.getElementById('btnClear').onclick = ()=>{ ctx.clearRect(0,0,canvas2d.width, canvas2d.height); }

  /******************************************************************
   * Three.js + WebXR
   ******************************************************************/
  let camera, scene, renderer;
  let reticle, controller;
  let hitTestSource = null;

  const threeContainer = document.getElementById('threeContainer');
  
  function initThree(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
    
    // Luz
    const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
    light.position.set(0.5, 1, 0.25);
    scene.add(light);
    
    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    threeContainer.appendChild(renderer.domElement);

    // --- CORREÇÃO: Usando o ARButton oficial ---
    // Ele gerencia a criação do botão e o início da sessão de AR.
    document.body.appendChild(THREE.ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test', 'anchors'] // Pedimos hit-test e âncoras para estabilidade
    }));
    
    // Retículo para indicar a superfície
    const ringGeo = new THREE.RingGeometry(0.06,0.08,32).rotateX(-Math.PI/2);
    const ringMat = new THREE.MeshBasicMaterial();
    reticle = new THREE.Mesh(ringGeo, ringMat);
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Controlador para capturar o toque na tela
    controller = renderer.xr.getController(0);
    controller.addEventListener('select', onSelect);
    scene.add(controller);

    // --- CORREÇÃO: Gerenciamento da UI e início da sessão ---
    renderer.xr.addEventListener('sessionstart', async (e) => {
        ui.classList.add('hidden'); // Esconde a UI principal
        canvas2d.style.display = 'block'; // Mostra o canvas de desenho
        statusEl.textContent = 'AR iniciado.';
        
        const session = renderer.xr.getSession();
        const viewerSpace = await session.requestReferenceSpace('viewer');
        hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

        // Carrega as artes do Firebase assim que a sessão começa
        loadArts();
    });

    renderer.xr.addEventListener('sessionend', () => {
        ui.classList.remove('hidden'); // Mostra a UI de novo ao sair
        canvas2d.style.display = 'none';
        statusEl.textContent = 'Sessão AR encerrada.';
        hitTestSource = null;
    });

    renderer.setAnimationLoop(animate);
  }

  function animate(timestamp, frame){
    if(frame){
      const referenceSpace = renderer.xr.getReferenceSpace();
      const hitTestResults = frame.getHitTestResults(hitTestSource);
      if(hitTestResults.length > 0){
        const hit = hitTestResults[0];
        reticle.visible = true;
        reticle.matrix.fromArray(hit.getPose(referenceSpace).transform.matrix);
      } else {
        reticle.visible = false;
      }
    }
    renderer.render(scene, camera);
  }

  async function onSelect(event){
    if(!reticle.visible) return;

    // --- CORREÇÃO: Cria uma âncora para estabilizar a arte ---
    const hitPose = event.frame.getHitTestResults(hitTestSource)[0].getPose(renderer.xr.getReferenceSpace());
    const anchor = await event.frame.createAnchor(hitPose.transform, renderer.xr.getReferenceSpace());

    const tex = new THREE.CanvasTexture(canvas2d);
    const material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent:true });
    const aspect = canvas2d.width / canvas2d.height;
    const height = 1.2;
    const width = height * aspect;
    const geom = new THREE.PlaneGeometry(width, height);
    const mesh = new THREE.Mesh(geom, material);
    
    // O mesh é adicionado à âncora, não diretamente à cena
    // A âncora já tem a posição e rotação corretas
    anchor.add(mesh);

    // Salva a arte no Firebase
    saveArt(mesh, width, height);
  }

  async function saveArt(mesh, width, height){
    const imageBlob = await new Promise(r => canvas2d.toBlob(r, 'image/png'));
    const filename = `arts/${Date.now()}.png`;
    const storageRef = storage.ref().child(filename);
    
    statusEl.textContent = 'Fazendo upload...';
    try {
        const uploadTask = await storageRef.put(imageBlob);
        const url = await uploadTask.ref.getDownloadURL();
        const user = auth.currentUser;
        
        const doc = {
            ownerUid: user ? user.uid : 'anon',
            imageURL: url,
            widthMeters: width,
            heightMeters: height,
            // Não salvamos a matriz, pois a âncora não é serializável.
            // A arte será recarregada via GPS no futuro (lógica a ser adicionada)
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        await db.collection('arts').add(doc);
        statusEl.textContent = 'Arte salva no Firebase!';
        // Limpa o canvas após salvar
        ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);

    } catch(e) {
        console.error("Erro no upload/salvamento:", e);
        statusEl.textContent = 'Erro ao salvar.';
    }
  }

  async function loadArts() {
    // Lógica para carregar artes via GPS seria adicionada aqui,
    // mas por enquanto, focamos em fazer o posicionamento funcionar.
    console.log("Função para carregar artes futuras.");
  }

  // --- Botão de salvar agora só dá a instrução ---
  document.getElementById('btnSave').onclick = ()=>{
    alert('Toque numa superfície plana (onde o anel branco aparece) para posicionar e salvar sua arte.');
  }

  // Inicia tudo
  initThree();

  </script>
</body>
</html>
